USING Simatic.Ax.Sinamics;

FUNCTION_BLOCK DriveCtrl
    
    VAR_INPUT
        enableAxis: BOOL;
        acknowledgeError: BOOL;
        /// see global SystemConstants for telegram xy generated by HWC / SinaSpeed use tel1 / SinaPos use tel111
        hwidSTW: UINT; 
        /// see global SystemConstants for telegram xy generated by HWC / SinaSpeed use tel1 / SinaPos use tel111
        hwidZSW: UINT;
        pos_position : DINT;
        pos_velocity : DINT;
        speed_moveForward: BOOL;
        speed_moveBackward: BOOL;
        speed_speedSetpoint: REAL;
        speed_referenceSpeed : REAL := 3000; // is configured in the drive config - pls.a adjust accordingly / relation to "reference-speed" prameter 2000 (expert list)
    END_VAR  
    VAR
        _sinaSpeed: SinaSpeed;
        _sinaPos: SinaPos;
    END_VAR

    {::ifdef MACHINE_SPEEDDRV_CONFIG}

    // check axis is enabled and select speed and direction
    IF _sinaSpeed.axisEnabled THEN
        IF speed_moveForward AND NOT speed_moveBackward THEN
            _sinaSpeed.speedSetpoint := speed_speedSetpoint;
        ELSIF speed_moveBackward AND NOT speed_moveForward THEN
            _sinaSpeed.speedSetpoint := -speed_speedSetpoint;
        ELSE
        _sinaSpeed.speedSetpoint := 0;
        END_IF;
    ELSE
        _sinaSpeed.speedSetpoint := 0;
    END_IF;

    // call sinaspeed cyclically
    _sinaSpeed( enableAxis := enableAxis, 
                acknowledgeError := acknowledgeError, 
                referenceSpeed := speed_referenceSpeed, 
                hwidSTW := hwidSTW, 
                hwidZSW :=hwidZSW);

    {::elseif MACHINE_POSDRV_CONFIG}

    // check axis is enabled and select speed and direction
    IF _sinaPos.axisEnabled THEN
        // select mode when axis is in standstill
        IF _sinaPos.axisPositionOk THEN
        _sinaPos.mode := SinaPosMode#RelativePositioning;

        // check mode is active and execute traversing job
        IF _sinaPos.actualMode = SinaPosMode#RelativePositioning THEN
            _sinaPos.position := pos_position;
            _sinaPos.velocity := pos_velocity;
            _sinaPos.executeMode := TRUE;
        END_IF;
        ELSE
        // reset job parameters whenever axis is moving
        _sinaPos.position := 0;
        _sinaPos.velocity := 0;
        _sinaPos.executeMode := FALSE;
        END_IF;
    END_IF;

    // call sinapos cyclically
    _sinaPos(   enableAxis := enableAxis, 
                acknowledgeError := acknowledgeError, 
                hwidSTW := hwidSTW, 
                hwidZSW := hwidZSW);
    {::endif}

END_FUNCTION_BLOCK